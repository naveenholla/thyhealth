import 'package:drift/drift.dart';
import 'connection/connection.dart';
import 'tables.dart';

part 'database.g.dart'; // This will be generated by drift_dev

@DriftDatabase(
  tables: [
    Patients,
    MedicalReports,
    TestResults,
  ],
)
class AppDatabase extends _$AppDatabase {
  // Constructor that uses the platform-specific connection
  AppDatabase() : super(connect());

  // Database version - increment this when schema changes
  @override
  int get schemaVersion => 1;

  // Migration strategy for handling schema changes
  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) {
          return m.createAll();
        },
        onUpgrade: (Migrator m, int from, int to) async {
          // Add migration logic here when schema version changes
        },
      );

  // CRUD operations for Patients
  Future<int> addPatient(PatientsCompanion patient) {
    return into(patients).insert(patient);
  }

  Future<Patient?> getPatientById(int id) {
    return (select(patients)..where((p) => p.id.equals(id))).getSingleOrNull();
  }

  Future<List<Patient>> getAllPatients() {
    return select(patients).get();
  }

  Stream<List<Patient>> watchAllPatients() {
    return select(patients).watch();
  }

  // CRUD operations for MedicalReports
  Future<int> addMedicalReport(MedicalReportsCompanion report) {
    return into(medicalReports).insert(report);
  }

  Future<List<MedicalReport>> getReportsByPatientId(int patientId) {
    return (select(medicalReports)..where((r) => r.patientId.equals(patientId))).get();
  }

  Stream<List<MedicalReport>> watchReportsByPatientId(int patientId) {
    return (select(medicalReports)..where((r) => r.patientId.equals(patientId))).watch();
  }

  // CRUD operations for TestResults
  Future<int> addTestResult(TestResultsCompanion result) {
    return into(testResults).insert(result);
  }

  Future<List<TestResult>> getTestResultsByReportId(int reportId) {
    return (select(testResults)..where((t) => t.reportId.equals(reportId))).get();
  }

  Stream<List<TestResult>> watchTestResultsByReportId(int reportId) {
    return (select(testResults)..where((t) => t.reportId.equals(reportId))).watch();
  }

  // Join query to get a report with all its test results
  Future<Map<MedicalReport, List<TestResult>>> getReportWithTestResults(int reportId) async {
    final report = await (select(medicalReports)..where((r) => r.id.equals(reportId))).getSingle();
    final results = await getTestResultsByReportId(reportId);
    return {report: results};
  }

  // Join query to get all reports with their test results for a patient
  Future<Map<MedicalReport, List<TestResult>>> getAllReportsWithTestResultsForPatient(int patientId) async {
    final reports = await getReportsByPatientId(patientId);
    final result = <MedicalReport, List<TestResult>>{};
    
    for (final report in reports) {
      final testResults = await getTestResultsByReportId(report.id);
      result[report] = testResults;
    }
    
    return result;
  }

  // Delete operations for Patients
  Future<int> deletePatient(int id) {
    return (delete(patients)..where((p) => p.id.equals(id))).go();
  }

  // Delete operations for MedicalReports
  Future<int> deleteMedicalReport(int id) {
    return (delete(medicalReports)..where((r) => r.id.equals(id))).go();
  }

  // Delete all reports for a patient
  Future<int> deleteReportsForPatient(int patientId) {
    return (delete(medicalReports)..where((r) => r.patientId.equals(patientId))).go();
  }

  // Delete operations for TestResults
  Future<int> deleteTestResult(int id) {
    return (delete(testResults)..where((t) => t.id.equals(id))).go();
  }

  // Delete all test results for a report
  Future<int> deleteTestResultsForReport(int reportId) {
    return (delete(testResults)..where((t) => t.reportId.equals(reportId))).go();
  }
} 